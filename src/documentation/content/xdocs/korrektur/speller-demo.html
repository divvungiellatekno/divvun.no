<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Divvun grammar and spell checker</title>
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 20px;
      }
      .container {
        max-width: 900px;
        margin: 0 auto;
        background: white;
        border-radius: 12px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        overflow: hidden;
      }
      .header {
        background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
        color: white;
        padding: 20px;
        text-align: center;
      }
      .header h1 {
        font-size: 2em;
        margin-bottom: 10px;
      }
      .controls {
        padding: 20px;
        background: #f8f9fa;
        border-bottom: 1px solid #e9ecef;
        display: flex;
        gap: 15px;
        align-items: center;
        flex-wrap: wrap;
      }
      .editor-container {
        padding: 20px;
      }
      .quill-editor {
        height: 70vh !important;
      }

      /* Quill error highlight */
      .ql-editor .grammar-typo {
        text-decoration: underline;
        text-decoration-color: red;
        text-decoration-style: wavy;
      }
      .ql-editor .grammar-other {
        text-decoration: underline;
        text-decoration-color: blue;
        text-decoration-style: wavy;
      }
      .status-bar {
        padding: 15px 20px;
        background: #f8f9fa;
        border-top: 1px solid #e9ecef;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      @media (max-width: 768px) {
        .controls {
          flex-direction: column;
          align-items: stretch;
        }
        .status-bar {
          flex-direction: column;
          gap: 10px;
          text-align: center;
        }
      }
    </style>
    <link
      href="https://cdn.quilljs.com/1.3.7/quill.snow.css"
      rel="stylesheet"
    />
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>Divvun grammar and spell checker</h1>
        <p></p>
      </div>
      <div class="controls">
  <div class="control-group">
    <label for="language-select">Language:</label>
    <select id="language-select">
      <option value="se">Davvisámegiella (Northern sami)</option>
      <option value="sma">Åarjelsaemien (Southern sami)</option>
      <option value="smj">Julevsámegiella (Lule sami)</option>
      <option value="smn">Anarâškielâ (Inari sami)</option>
      <option value="sms">Nuõrttsääʹmǩiõll  (Skolt sami)</option>
    </select>
  </div>
  <div class="control-group">
    <button id="clear-btn">Clear</button>
  </div>
</div>
<div class="editor-container">
  <div id="editor" class="quill-editor"></div>
</div>
<div class="status-bar">
  <div class="status" id="status-display">
    <span id="status-text">Ready</span>
  </div>
  <div class="error-count" id="error-count">0 errors</div>
</div>

    </div>
    <script src="https://cdn.quilljs.com/1.3.7/quill.min.js"></script>
    <script>
(() => {
  const Q = globalThis.Quill;
  if (!Q) {
    // Defer throwing so page can still load; will throw when create() is called
    globalThis.QuillBridge = {
      create: () => {
        throw new Error(
          "Quill is not loaded. Include Quill CDN before using the bridge."
        );
      },
    };
    return;
  }

  const bridge = {
    create(container, options) {
      const el =
        typeof container === "string"
          ? document.getElementById(container)
          : container;
      if (!el) throw new Error("QuillBridge.create: container not found");
      const quill = new Q(el, options || {});

      return {
        root: quill.root,
        getText: () => quill.getText(),
        on: (ev, handler) => quill.on(ev, handler),
        getLength: () => quill.getLength(),
        formatText: (i, len, format, value) =>
          quill.formatText(i, len, format, value),
        setText: (text) => {
          quill.setText(text);
        },
        deleteText: (i, len) => quill.deleteText(i, len),
        insertText: (i, text) => quill.insertText(i, text),
        focus: () => quill.focus(),
        // helpers using Quill internals
        findBlot: (node) => Q.find(node),
        getIndex: (blot) => quill.getIndex(blot),
      };
    },
  };

  globalThis.QuillBridge = bridge;
})();
    </script>
    <script>
      // Register custom Quill blots for error highlighting
      const Inline = Quill.import('blots/inline');
      class GrammarTypoBlot extends Inline {
        static create(value) {
          let node = super.create();
          node.classList.add('grammar-typo');
          return node;
        }
        static formats(node) {
          return 'grammar-typo';
        }
      }
      GrammarTypoBlot.blotName = 'grammar-typo';
      GrammarTypoBlot.tagName = 'span';

      class GrammarOtherBlot extends Inline {
        static create(value) {
          let node = super.create();
          node.classList.add('grammar-other');
          return node;
        }
        static formats(node) {
          return 'grammar-other';
        }
      }
      GrammarOtherBlot.blotName = 'grammar-other';
      GrammarOtherBlot.tagName = 'span';

      Quill.register(GrammarTypoBlot);
      Quill.register(GrammarOtherBlot);

      if (document.getElementById("editor")) {
        const quill = new Quill("#editor", {
          theme: "snow",
        });

        quill.root.setAttribute("spellcheck", "false");
        quill.root.oncontextmenu = (e) => {
          e.preventDefault();
          const caret = document.caretPositionFromPoint(e.clientX, e.clientY);
          if (caret) {
            const blot = Quill.find(caret.offsetNode);
            if (blot) {
              const index = quill.getIndex(blot) + caret.offset;
              const err = currentErrs.find(e => e.start_index <= index && index < e.end_index);
              if (err && err.suggestions && err.suggestions.length > 0) {
                showSuggestionsMenu(e.clientX, e.clientY, err.suggestions, (suggestion) => {
                  quill.formatText(err.start_index, err.end_index - err.start_index, err.error_code === 'typo' ? 'grammar-typo' : 'grammar-other', false);
                  quill.deleteText(err.start_index, err.end_index - err.start_index);
                  quill.insertText(err.start_index, suggestion);
                });
              }
            }
          }
        };

        let currentErrs = [];

        function showSuggestionsMenu(x, y, suggestions, onSelect) {
          const existing = document.getElementById('suggestions-menu');
          if (existing) existing.remove();
          const menu = document.createElement('div');
          menu.id = 'suggestions-menu';
          menu.style.position = 'absolute';
          menu.style.left = x + 'px';
          menu.style.top = y + 'px';
          menu.style.background = 'white';
          menu.style.border = '1px solid #ccc';
          menu.style.boxShadow = '0 2px 10px rgba(0,0,0,0.1)';
          menu.style.zIndex = '1000';
          suggestions.forEach(s => {
            const btn = document.createElement('button');
            btn.textContent = s;
            btn.style.display = 'block';
            btn.style.width = '100%';
            btn.style.padding = '5px 10px';
            btn.style.border = 'none';
            btn.style.background = 'none';
            btn.style.cursor = 'pointer';
            btn.onmouseover = () => btn.style.background = '#f0f0f0';
            btn.onmouseout = () => btn.style.background = 'none';
            btn.onclick = () => {
              onSelect(s);
              menu.remove();
            };
            menu.appendChild(btn);
          });
          document.body.appendChild(menu);
          const close = (e) => {
            if (!menu.contains(e.target)) {
              menu.remove();
              document.removeEventListener('click', close);
            }
          };
          setTimeout(() => document.addEventListener('click', close), 0);
        }

        let debounceTimer;

        quill.on('text-change', (delta, oldDelta, source) => {
          if (source === 'user') {
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(async () => {
              const text = quill.getText();
              const lang = languageSelect.value;
              try {
                clearHighlights();
                const result = await checkGrammar(text, lang);
                highlightErrors(result.errs);
                let count = result.errs?.length || 0;
                errorCount.textContent = `${count} error${count !== 1 ? "s" : ""}`;
              } catch (e) {
                console.error("error:", e);
                errorCount.textContent = "0 errors";
              }
            }, 800);
          }
        });

        const checkBtn = document.getElementById("check-btn");
        const clearBtn = document.getElementById("clear-btn");
        const statusText = document.getElementById("status-text");
        const errorCount = document.getElementById("error-count");
        const languageSelect = document.getElementById("language-select");

        async function checkGrammar(text, lang) {
          if (!text.trim()) {
            return { text, errs: [] };
          }

          const response = await fetch(
            "https://api-giellalt.uit.no/grammar/" + lang,
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({ text }),
            }
          );

          if (!response.ok) {
            throw new Error(
              `API request failed with status ${response.status}`
            );
          }

          return await response.json();
        }

        function clearHighlights() {
          const length = quill.getLength();
          quill.formatText(0, length, "grammar-typo", false);
          quill.formatText(0, length, "grammar-other", false);
          currentErrs = [];
        }

        function highlightErrors(errs) {
          currentErrs = errs;
          errs.forEach((err) => {
            const start = err.start_index;
            const len = err.end_index - start;
            const isTypo =
              err.error_code === "typo" ||
              (err.title && err.title.toLowerCase().includes("typo"));
            const format = isTypo ? "grammar-typo" : "grammar-other";
            quill.formatText(start, len, format, true);
          });
        }

        checkBtn.addEventListener("click", async () => {
          statusText.textContent = "Checking...";
          const text = quill.getText();
          const lang = languageSelect.value;
          try {
            clearHighlights();
            const result = await checkGrammar(text, lang);
            highlightErrors(result.errs);
            let count = result.errs?.length || 0;
            errorCount.textContent = `${count} error${count !== 1 ? "s" : ""}`;
            statusText.textContent = "Complete";
          } catch (e) {
            console.error("error:", e);
            statusText.textContent = "Error";
            errorCount.textContent = "0 errors";
          }
        });

        clearBtn.addEventListener("click", () => {
          clearTimeout(debounceTimer);
          quill.setText("");
          clearHighlights();
          errorCount.textContent = "0 errors";
          statusText.textContent = "Ready";
        });
      }
    </script>
  </body>
</html>
